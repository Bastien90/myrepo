---
title: "Covid 19 Forecast"
output: 
  html_document:
    keep_md: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Libraries and  Raw Data
```{r lib, message=FALSE, warning=FALSE}
library(googleVis)
op <- options(gvis.plot.tag='chart')
library(lubridate)
library(fpp3)
library(tidyverse)
library(tsibble)
library(feasts)
library(ggplot2)
library(WDI)
library(DataExplorer)
library(recipes)
library(tidymodels)
library(scales)
library(gridExtra)
library(highcharter)
library(GGally)
library(corrplot)
library(ggthemes)
library(zoo)
library(anomalize)
library(vip)
library(tidycovid19)
library(usethis)
library(htmltools)
use_git_config(user.name = "Bastien90", user.email = "bastienhaller@web.de")

theme_set(theme_minimal())

#setting parameters
sub_set <- FALSE # only train on subset of the data
retrain_ts <- TRUE # retrain time series models#
train_challenger <- FALSE #train a challenger model once a week

covid <- read_csv("data/covid19.csv")

#download new data if available
if(max(covid$date) < today() -days(1) ){

  covid_new <- tidycovid19::download_jhu_csse_covid19_data()
  
  #additional check
  if(nrow(covid_new) > nrow(covid)){
  covid <- covid_new
  rm(covid_new)
  write_csv(covid, "data/covid19.csv")
  }
}

paste0("period covered: ", min(covid$date), " - ", max(covid$date)) %>% print()

#Goal to predict last two weeks
period <- 14

train <- covid %>% filter(date <= max(date) - days(14))

test <- covid %>% filter(date > max(date) - days(14))

paste0("train: ", min(train$date), " - ", max(train$date)) %>% print()
paste0("test: ", min(test$date), " - ", max(test$date)) %>% print()




set.seed(123)
sampled_id <- unique(train$country )[sample(1 : length(unique(train$country)), 10)]
sampled_id <- c(sampled_id, "Italy", "France", "Germany", "Sweden", "US", "Thailand", "China", "Afghanistan")

if(sub_set){
train <- train %>% filter(country %in% sampled_id)

test <- test %>% filter(country %in% sampled_id)
}

```

# EDA and Additional World Bank Data

```{r EDA, results='asis', tidy=FALSE, message=FALSE, warning=FALSE}
#First detected case
day_of_first_case <-  train %>%
  filter(confirmed > 0) %>%
  group_by(iso3c) %>%
  summarise(day_of_first_case = min(date)) %>%
  ungroup()

train <- train %>%
         inner_join(day_of_first_case, by = "iso3c") %>%
          mutate(
          days_since_first_case = as.numeric(difftime(date, day_of_first_case, units ="days")),
          days_since_first_case =ifelse(days_since_first_case < 0, -1, days_since_first_case),
          days_since_global_outbreak  = as.numeric(difftime(date, min(date), units ="days")))


test <- test %>%
         inner_join(day_of_first_case, by = "iso3c") %>%
          mutate(
          days_since_first_case = as.numeric(difftime(date, day_of_first_case, units ="days")),
          days_since_first_case =ifelse(days_since_first_case < 0, -1, days_since_first_case),
          days_since_global_outbreak  = as.numeric(difftime(date, min(date), units ="days")))


train %>% filter(confirmed > 0) %>%
hchart(., "line", hcaes(x = days_since_first_case, y = confirmed, group = country)) %>%
list() %>%
htmltools::tagList(.)  

#WDI Data
if(!file.exists("data/wdi_dat.csv")){
  wdi_dat <- WDI(indicator = c(
                               "SP.POP.TOTL",
                               "NY.GDP.PCAP.KD",
                               "SP.DYN.LE00.IN", 
                               "SP.DYN.IMRT.IN", 
                               "ST.INT.DPRT",
                               "ST.INT.ARVL",
                               "SH.MED.PHYS.ZS",
                               "SH.MED.NUMW.P3",
                               "SH.MED.BEDS.ZS",
                               "IQ.CPA.PROT.XQ",
                               "IQ.CPA.PADM.XQ",
                               "SI.POV.GINI",
                               "SH.DTH.COMM.ZS",
                               "SH.MED.CMHW.P3",
                               "SH.XPD.CHEX.PP.CD",
                               "SH.STA.HYGN.ZS",
                               "SP.POP.65UP.TO.ZS",
                               "SP.URB.TOTL.IN.ZS",
                               "EN.POP.SLUM.UR.ZS",
                               "per_si_allsi.cov_pop_tot"
                               
                               ), start = 1960, end = 2018, extra = TRUE)
  write.csv(wdi_dat, "data/wdi_dat.csv", row.names = FALSE)
} else {
  wdi_dat <- read_csv("data/wdi_dat.csv")
}

#lattest value per country
wdi_agg <- wdi_dat %>% 
            filter(region != "Aggregates") %>%
            mutate(longitude = as.numeric(as.character(longitude)),
                   latitude = as.numeric(as.character(latitude))) %>%
            arrange(iso2c, country, year) %>%
            group_by(iso2c, iso3c, region) %>%
            summarise_if(is.numeric, ~dplyr::last(na.omit(.))) %>%
            ungroup()

wdi_agg %>% plot_missing()
#select only vars with <11% missing values
vars <- map_df(wdi_agg, ~sum(is.na(.)) / length(.) * 100)  %>%
          gather() %>%
          filter(value < 11 ) %>%
          pull(key)

wdi_agg <- wdi_agg %>% select(all_of(vars))

#combine timeseries and wdia data
train <- train %>% 
         left_join(wdi_agg, by ="iso3c") %>%
         filter(!is.na(region))

test <- test %>% 
        left_join(wdi_agg, by ="iso3c") %>%
        filter(!is.na(region))


#calculaute per 100K
k <- 10 ^ 5
train <- train %>%
         mutate(Fatalities_per_100K = deaths / SP.POP.TOTL * k,
                ConfirmedCases_per_100K = confirmed / SP.POP.TOTL * k,
                Recovered_per_100K = recovered / SP.POP.TOTL * k,
                )

```

```{r warning=FALSE, message=FALSE, results='asis', tidy=FALSE}
train %>% 
  filter(date == max(date)) %>%
  select(iso2c, confirmed) %>%
  filter(!is.na(iso2c)) %>%
  gvisGeoChart(locationvar = "iso2c", 
                 colorvar = "confirmed",
                 options = list(projection="kavrayskiy-vii",
                              colorAxis="{colors:['#91BFDB', '#FC8D59']}",
                              gvis.editor="Choose Region")) %>%
  plot()
```


```{r warning=FALSE, message=FALSE, results='asis', tidy=FALSE, fig.width=16, fig.height=12}
train %>% 
  filter(date == max(date)) %>%
  select(iso2c, confirmed, ConfirmedCases_per_100K, deaths, Fatalities_per_100K, recovered,  Recovered_per_100K) %>%
  drop_na()%>%
  as.data.frame() %>%
  gvisIntensityMap(.) %>%
  plot()

```

```{r warning=FALSE, message=FALSE}
# Motion <- gvisMotionChart(train %>%
#                             select(-timestamp, -latitude, -longitude),                       ,
#                         idvar="country",
#                         xvar ="confirmed",
#                         yvar = "deaths",
#                         timevar="date")
# #Motion$html$caption=""
# plot(Motion)

make_scatter <- function(x, y, xlog = TRUE, ylog = TRUE){
  plot <- train %>%
    filter(date == max(date)) %>%
    ggplot(aes_string( y = y,  x = x)) +
    geom_jitter() 
  if(ylog){
   plot <- plot +  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
  }
  if(xlog){
    plot <- plot +  scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))
  }
return(plot)
}

wdi <- names(wdi_agg)[5 : (ncol(wdi_agg) - 2)]
scatter_cases <- map(wdi,make_scatter, "confirmed")

n <- length(scatter_cases)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(scatter_cases, ncol = nCol))

scatter_fatalities <- map(wdi, make_scatter, "deaths", ylog = TRUE)

n <- length(scatter_fatalities)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(scatter_fatalities, ncol = nCol))

train %>% 
  filter(date == max(date)) %>%
    select(-c(days_since_global_outbreak ,Fatalities_per_100K, ConfirmedCases_per_100K, year )) %>%
    select(deaths, confirmed, everything()) %>%
  drop_na() %>%
  select_if(is.numeric) %>%
  ggpairs()

train %>% 
  filter(date == max(date)) %>%
  select(-c(days_since_global_outbreak ,Fatalities_per_100K, ConfirmedCases_per_100K, year, Recovered_per_100K, longitude, latitude )) %>%
  drop_na() %>%
  select_if(is.numeric) %>%
  cor() %>%
  corrplot(., method = "number")

```

# Goverment Interventions

```{r gov, message=FALSE, warning=FALSE}
#https://github.com/joachim-gassen/tidycovid19


gov <- read_csv("data/gov.csv")

# #download new data if available
# if(max(as.Date(gov$timestamp)) < today() - days(1) ){
# 
#   gov_new <- download_acaps_npi_data()
# 
#   #additional check
#   if(nrow(gov_new) > nrow(gov)){
#   gov <- gov_new
#   rm(gov_new)
#   write_csv(gov, "data/gov.csv")
#   }
# }

gov$date_implemented <- as.Date(gov$date_implemented)


gov %>%
  count(category) %>%
  ggplot(aes(y = n, x = reorder(category, n))) +
  geom_bar(stat = "identity") +
  ggtitle("Government Intervention Categories") +
  xlab("") +
  coord_flip() +
  ggtitle("Overview Categories Government Inverventions")

gov %>%
  count(measure) %>%
  ggplot(aes(y = n, x = reorder(measure, n))) +
  geom_bar(stat = "identity") +
  ggtitle("Government Measures") +
  xlab("") +
  coord_flip() +
  ggtitle("Overview Measures")


gov %>% count(category, date_implemented) %>%
  ggplot(aes(x = date_implemented, y = n, fill = category)) +
  geom_col() +
  xlab("Date") +
  ylab("Number of Interventions") +
  theme(legend.position="bottom") +
  ggtitle("Timeline Government Interventions")


  train %>%
              select(iso3c, iso2c, date, region, days_since_first_case) %>%
              inner_join(gov %>% count(category, date_implemented, iso3c),
                         by = c("iso3c", "date" = "date_implemented")) %>%
  group_by(days_since_first_case, category) %>%
  summarise(n = sum(n)) %>%
  ggplot(aes(x = days_since_first_case, y = n, fill = category)) +
  geom_col() +
  scale_fill_tableau() +
  ylab("Number of Interventions") +
  xlab("Days since first case detected") +
  ggtitle("Government Intervention since first case detected in country")

#wide format government intervention

categories_list <- unique(gov$category)

#Median Growth Rate of different government measures
measures_plot1 <- map(categories_list, ~
train %>%
              select(iso3c, iso2c, date, region, days_since_first_case, confirmed) %>%
              left_join(gov %>% group_by(category,iso3c) %>%
              filter(category == .x) %>%
  summarise(n = n(), date_implemented =  min(date_implemented,na.rm =TRUE)),
                         by = c("iso3c")) %>%
  group_by(iso2c) %>%
  mutate(ConfirmedCases_ma = rollapply(confirmed, width = 7,
                                       FUN = sum, align = "right", fill =NA),
         growthrate = ConfirmedCases_ma / lag(ConfirmedCases_ma)- 1,
         doubling_time = log(2) / log(growthrate + 1)) %>%
  filter(!is.na(growthrate)) %>%
  mutate(measure_implemented = case_when(is.na(date_implemented) ~ "not implemented",
         date < date_implemented ~ "not implemented",
         TRUE ~ "implemented")) %>%
  group_by(measure_implemented, days_since_first_case) %>%
  summarise(mean = mean(growthrate),
            std_err = sd(growthrate)/sqrt(n()),
             n = n()) %>%
  filter(n > 5 & days_since_first_case < 40 ) %>%
    ggplot(aes(x = days_since_first_case, y = mean, color =measure_implemented )) +
    geom_pointrange(
      aes(ymin = mean-1.96*std_err, ymax = mean+1.96*std_err),
      position=position_dodge(0.4)
    ) +
    labs(
      x = "Days since first case detected",
      y = "Growth Rate Confirmed Cases",
      color = .x
    ) +
    theme_minimal() +
    theme(
      legend.position = c(0.75, 0.75),
      plot.title.position = "plot",
      plot.caption.position =  "plot",
      plot.caption = element_text(hjust = 0),
      axis.title.x = element_text(hjust = 1),
      axis.title.y = element_text(hjust = 1),
    ) +
    scale_y_continuous(labels = scales::percent) +
   scale_color_tableau()
)

n <- length(measures_plot1)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(measures_plot1, ncol = nCol))

###Box plot of growth rate by days implemented
measure_plot3 <- map(categories_list, ~ train %>%
  select(iso3c, iso2c, date, region, days_since_first_case, confirmed) %>%
  left_join(gov %>% group_by(category,iso3c) %>%
              filter(category == .x) %>%
              summarise(n = n(), date_implemented =  min(date_implemented,na.rm =TRUE)),
            by = c("iso3c")) %>%
  group_by(iso2c) %>%
  mutate(ConfirmedCases_ma = rollapply(confirmed, width = 7,
                                       FUN = sum, align = "right", fill =NA),
         growthrate = ConfirmedCases_ma / lag(ConfirmedCases_ma)- 1,
         doubling_time = log(2) / log(growthrate + 1)) %>%
  filter(!is.na(growthrate)) %>%
  ungroup() %>%
  mutate(days_implemented = difftime(date, date_implemented, units = "days")) %>%
  filter(days_implemented >= 0 & days_implemented < 40)  %>%
  ggplot(aes(x = factor(days_implemented), y =  growthrate)) +
  geom_boxplot() +
  xlab( paste0("Days ", .x, " is in place" )) +
  ylab("Growth Rate Confirmed Cases") +
  scale_y_continuous(labels = scales::percent)
)

n <- length(measure_plot3)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(measure_plot3, ncol = nCol))


measures_list <- unique(gov$measure)

measure_plot4 <- map(measures_list, ~ train %>%
  select(iso3c, iso2c, date, region, days_since_first_case, confirmed) %>%
  left_join(gov %>% group_by(measure, iso3c) %>%
              filter(measure == .x) %>%
              summarise(n = n(), date_implemented =  min(date_implemented,na.rm =TRUE)),
            by = c("iso3c")) %>%
  group_by(iso2c) %>%
  mutate(ConfirmedCases_ma = rollapply(confirmed, width = 7,
                                       FUN = sum, align = "right", fill =NA),
         growthrate = ConfirmedCases_ma / lag(ConfirmedCases_ma)- 1,
         doubling_time = log(2) / log(growthrate + 1)) %>%
  filter(!is.na(growthrate)) %>%
  ungroup() %>%
  mutate(days_implemented = difftime(date, date_implemented, units = "days")) %>%
  filter(days_implemented >= 0 & days_implemented < 40)  %>%
  ggplot(aes(x = factor(days_implemented), y =  growthrate)) +
  geom_boxplot() +
  xlab( paste0("Days ", .x, " is in place" )) +
  ylab("Growth Rate Confirmed Cases") +
  scale_y_continuous(labels = scales::percent)
)

n <- length(measure_plot4)
nCol <- floor(sqrt(n))
do.call("grid.arrange", c(measure_plot4, ncol = nCol))

 

```

# SIR Process

```{r sir, message=FALSE, warning=FALSE}
#SIR MODEL Global
sir <- covid %>%
             inner_join(wdi_agg, by = "iso3c") %>%
             group_by(country) %>%
             mutate(day = rank(date)) %>%
             filter(!is.na(SP.POP.TOTL)) %>%
            mutate(susceptible  = SP.POP.TOTL - deaths - recovered,
                   infected = confirmed,
                   resistant  = deaths + recovered,
                   new_cases = confirmed - lag(confirmed)) %>%
              ungroup()


sir %>%
filter(country == "Germany") %>%
ggplot(aes(x = day )) +
geom_line(aes(y = susceptible, color = "susceptible"), size = 1) +
geom_line(aes(y = infected, color = "infected"), size = 1) +
geom_line(aes(y = resistant, color = "resistant"), size = 1) +
  scale_color_manual(values = c(
    'susceptible' = 'darkorange',
    'resistant' = 'darkgreen',
    'infected' = 'darkblue')) +
  labs(color = '') +
  ggtitle("SIR Process Germany") +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
   labels = trans_format("log10", math_format(10^.x)))

sir %>%
filter(country == "Germany") %>%
  ggplot(aes(x = day )) +
  geom_line(aes(y = confirmed, color = "Total Cases"), size = 1) +
  geom_line(aes(y = new_cases, color = "New Cases"), size = 1) +
  scale_color_manual(values = c(
    'New Cases' = 'darkgreen',
    'Total Cases' = 'darkblue')) +
  labs(color = '') +
  ggtitle("SIR Process Germany")

sir %>%
  group_by(day) %>%
  summarise_if(is.numeric, sum) %>%
  ggplot(aes(x = day )) +
geom_line(aes(y = susceptible, color = "susceptible"), size = 1) +
geom_line(aes(y = infected, color = "infected"), size = 1) +
geom_line(aes(y = resistant, color = "resistant"), size = 1) +
  scale_color_manual(values = c(
    'susceptible' = 'darkorange',
    'resistant' = 'darkgreen',
    'infected' = 'darkblue')) +
  labs(color = '') +
  ggtitle("SIR Process world-wide") +
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
   labels = trans_format("log10", math_format(10^.x)))

sir %>%
  group_by(day) %>%
  summarise_if(is.numeric, sum) %>%
    ggplot(aes(x = day )) +
  geom_line(aes(y = confirmed, color = "Total Cases"), size = 1) +
  geom_line(aes(y = new_cases, color = "New Cases"), size = 1) +
  scale_color_manual(values = c(
    'New Cases' = 'darkgreen',
    'Total Cases' = 'darkblue')) +
  labs(color = '') +
  ggtitle("SIR Process world-wide")


```

# Time Series Plots
```{r ts, message=FALSE, warning=FALSE}

train_ts <- train %>%
                as_tsibble(
                index = date,
                key = country
              )

confirmed_cases_features <- train_ts %>%
                            features(confirmed, feat_stl)

confirmed_cases_features %>%
  select(2 : 10) %>%
  ggpairs()

pcs <- train_ts %>%
      features(confirmed, feat_stl) %>%
      select(2 : 10) %>%
      prcomp(scale = TRUE) %>%
broom::augment(confirmed_cases_features)


pcs %>% ggplot(aes(x=.fittedPC1, y=.fittedPC2)) +
geom_point() + theme(aspect.ratio=1)


outlier <- pcs %>%
  filter(.fittedPC1 == max(.fittedPC1)) %>%
  pull(country)

train_ts %>%
  filter(country == outlier) %>%
  feasts::autoplot(confirmed)

#Decompose a time series in preparation for anomaly detection
# Seasonal-Trend-Loess (STL) Decomposition in the form of “observed”, “season”, “trend” and “remainder”
set.seed(123)
sampled_id <- unique(train$country )[sample(1 : length(unique(train$country)), 10)]
sampled_id <- c(sampled_id, "Italy", "France", "Germany", "Sweden", "US", "Thailand", "China", "Afghanistan")

#show subset of countries
train %>%
  filter(country %in% sampled_id) %>%
  group_by(country) %>%
    arrange(date) %>%
    mutate(confirmed = log(confirmed + 1 )) %>%
    time_decompose(confirmed) %>%
    anomalize(remainder) %>%
    time_recompose() %>%
    plot_anomalies(ncol = 3, alpha_dots = 0.3)
# the STL has some problems to detect the exponential trend in some cases

```
# Feature Engineering
## WDI
```{r wdi, message=FALSE, warning=FALSE}


 train  %>% plot_missing()

```
## Goverment Interventions
```{r govfeatures, message=FALSE, warning=FALSE}
gov_wide <- gov %>%
            filter(is.na(admin_level_name)) %>%
            mutate(category = str_trim(str_replace_all(category, " ", "_")),
                   category = str_replace_all(category, "[[:punct:]]", "")) %>%
            group_by(iso3c, category) %>%
            summarise(date_implemented = min (date_implemented, na.rm = TRUE)) %>%
            ungroup() %>%
            pivot_wider(names_from = category, values_from = date_implemented)

categories_list <-  str_trim(str_replace_all(categories_list, " ", "_")) %>%
                    str_replace_all(., "[[:punct:]]", "")

measures_list <-    str_trim(str_replace_all(measures_list, " ", "_")) %>%
                    str_replace_all(., "[[:punct:]]", "") %>%
                    str_to_lower(.)

gov_measures <-  gov %>%
                 #measure should be at leat 14 days in place
                 mutate(date_implemented = date_implemented + days(14),
                        measure = str_to_lower(str_trim(str_replace_all(measure, " ", "_"))),
                        measure = str_replace_all(measure, "[[:punct:]]", "")) %>%
                 count(measure, date_implemented, iso3c) %>%
                 rename(distance_measures = n) %>%
                 pivot_wider(names_from = measure, values_from = distance_measures)

overall_distancing_measures <- gov %>%
                              #measure should be at leat 14 days in place
                              mutate(date_implemented = date_implemented + days(14)) %>%
                              filter(category %in% c("Social distancing",
                                                     "Movement restrictions", "Lockdown")) %>%
                              count(date_implemented, iso3c) %>%
                              rename(distance_measures = n)


train <- train %>%
         left_join(gov_measures, c("iso3c", "date" = "date_implemented")) %>%
         mutate_at(.vars = measures_list, ~  cumsum(coalesce(., 0L)) ) %>%
         left_join(overall_distancing_measures, by = c("iso3c", "date" = "date_implemented")) %>%
         group_by(country) %>%
         mutate(distance_measures = cumsum(coalesce(distance_measures, 0L)))

test <- test %>%
         left_join(gov_measures, c("iso3c", "date" = "date_implemented")) %>%
         mutate_at(.vars = measures_list, ~  cumsum(coalesce(., 0L)) ) %>%
         left_join(overall_distancing_measures, by = c("iso3c", "date" = "date_implemented")) %>%
         group_by(country) %>%
         mutate(distance_measures = cumsum(coalesce(distance_measures, 0L))) %>%
         ungroup()


```

## Lagged Features
https://gist.github.com/drsimonj/2038ff9f9c67063f384f10fac95de566

```{r lag, message=FALSE, warning=FALSE}

lag <- 14
lags <- seq(lag)
lag_names <- paste("diff_cases_lag", formatC(lags, width = nchar(max(lags)), flag = "0"),
                   sep = "_")
lag_functions_cases <- setNames(paste("dplyr::lag(., ", lags, ")"), lag_names)

train <- train %>%
        group_by(country) %>%
        arrange(country, date) %>%
        mutate(log_cases = log(confirmed + 1),
                log_cases = log_cases - lag(log_cases),
               rolling_mean_7 = rollapply(log_cases,
                                mean, align = "right", fill = NA, width = list(-(7:1)))) %>%
        mutate_at(vars(log_cases), funs_(lag_functions_cases)) %>%
        ungroup()

test <- test %>%
        bind_rows(train,.id = "data_set") %>% # combine with train to calculate the lags
        group_by(country) %>%
        arrange(country, date) %>%
        mutate(log_cases = log(confirmed + 1),
                log_cases = log_cases - lag(log_cases),
                rolling_mean_7 = rollapply(log_cases,
                                mean, align = "right", fill = NA, width = list(-(7:1)))) %>%
        mutate_at(vars(log_cases), funs_(lag_functions_cases)) %>%
        ungroup() %>%
        filter(data_set == 1) %>%
        select(-data_set)


#combine lagged features with training data
train_lagged <- train %>%
                filter(date >= min(date) + days(lag + 1)) %>%
                arrange(date, country)
```
# ML Models
## Recursive Strategy
https://www.statworx.com/de/blog/time-series-forecasting-with-random-forest/
```{r recursive, message=FALSE, warning=FALSE}
#columns to remove
col_rem <- c("country", "iso3c", "date", "deaths", "timestamp", "day_of_first_case",
              "distance_measures", "iso2c", "year", "confirmed", "recovered", "ConfirmedCases_per_100K", "Fatalities_per_100K","Recovered_per_100K")

train_cases <- train_lagged %>%
               select(- all_of(col_rem))

#prepare data for modelling
recipe_confirmedcases <- recipe(log_cases ~ ., train_cases) %>%
  step_medianimpute(all_numeric(), -all_outcomes()) %>%
  step_center(all_numeric(), -all_outcomes()) %>%
  step_scale(all_numeric(), -all_outcomes()) %>%
  step_zv(all_predictors(), -all_outcomes()) %>%
  step_dummy(all_nominal(), -all_outcomes()) %>%
  prep(data = train_cases)


training_set <-  train_lagged  %>%
  #filter(date <= max(date) - days(period)) %>%
  select(- all_of(col_rem)) %>%
  bake(recipe_confirmedcases, new_data = .) %>%
  select(log_cases, everything())

#show Folds for training (Date Column is required)
n_countries <- train_lagged %>% distinct(country) %>% nrow()
init <- 42
rolling_folds <- train_lagged  %>%
                 rolling_origin(.,
                                initial =  init * n_countries,
                                assess =  7 * n_countries,
                                skip = 7 * n_countries,
                                cumulative = TRUE)

#print folds using the date column
for(i in 1: length(rolling_folds$splits)){
  model_from <- rolling_folds$splits[[i]] %>% analysis() %>% pull(date) %>% min()
  model_to <- rolling_folds$splits[[i]] %>% analysis() %>% pull(date) %>% max()
  assesment_from <- rolling_folds$splits[[i]] %>% assessment() %>% pull(date) %>% min()
  assesment_to <- rolling_folds$splits[[i]] %>% assessment() %>% pull(date) %>% max()
  print(paste0("Fold ", i))
  print(paste0("Modelling ", model_from, " - ", model_to ))
  print(paste0("Assesment ", assesment_from, " - ", assesment_to ))
}



#Create Folds for modeling excluding date column
n_countries <- train %>% distinct(country) %>% nrow()
rolling_folds <- training_set %>%
                 rolling_origin(.,
                                initial =  init * n_countries,
                                assess =  7 * n_countries,
                                skip = 7 * n_countries,
                                cumulative = TRUE)

# xgboost – Model Spec
xgboost_model <- boost_tree(
        mode       = "regression",
        trees      = tune(),
        min_n      = tune(),
        tree_depth = tune(),
        learn_rate = tune()
    ) %>%
    set_engine("xgboost", objective = "reg:squarederror")

xgboost_model


#xgboost – Grid Spec
xgboost_params <- parameters(trees(), min_n(), tree_depth(), learn_rate())
xgboost_params

set.seed(123)
xgboost_grid <- grid_max_entropy(xgboost_params, size = 30)
xgboost_grid

#train a challenger model once a week

 if(train_challenger){
  #xgboost – Hyperparameter Tuning
  challenger_tune <- tune_grid(log_cases ~ .,
                        model =  xgboost_model,
                        resamples = rolling_folds,
                        metrics   = metric_set(mae, mape, rmse, rsq),
                        grid = xgboost_grid)
  saveRDS(challenger_tune, "models/challenger_model.rds")

# select best params
params_challenger_best <- challenger_tune %>%
    select_best("mae", maximize = FALSE)

#Finalize the Model for testing
challenger_finalized <- xgboost_model %>%
    finalize_model(params_challenger_best)

challenger_fit <- challenger_finalized %>%
                fit(log_cases ~.,
                    training_set)

 }

#read model
xgb_tune <- readRDS("models/model.rds")

#Compare and Select Best Model
xgb_tune %>% show_best("mae", n = 3, maximize = FALSE)
xgb_tune %>% select_best("mae", maximize = FALSE)

params_xgboost_best <- xgb_tune %>%
    select_best("mae", maximize = FALSE)

#Finalize the Model for testing
xgboost_finalized <- xgboost_model %>%
    finalize_model(params_xgboost_best)

xgboost_fit <- xgboost_finalized %>%
                fit(log_cases ~.,
                    training_set)

vip(xgboost_fit) +
    labs(title = "XGBoost Model Importance")

#training set prediction
train_pred_direct_xgb <- xgboost_fit %>% predict(training_set) %>% rename(xgb_direct = .pred)

#check performance on test data
#onstep ahead forecast
recursive_pred <- function(model){
test_dates <- test  %>% distinct(date)
test_data <- train_lagged %>%
  filter( date > max(date) - days(lag)) %>%
  bind_rows(test)
i <- 1

for(i in 1 : nrow(test_dates)){
  new_data <- test_data %>%
              filter(date > test_dates$date[i] - days(period) & date <= test_dates$date[i])
   new_data <- new_data %>%
                group_by(country) %>%
                mutate(rolling_mean_7 = rollapply(log_cases,
                                mean, align = "right", fill = NA, width = list(-(7:1)))) %>%
                mutate_at(vars(log_cases), funs_(lag_functions_cases)) %>%
                ungroup() %>%
                filter(date == test_dates$date[i]) %>%
                bake(recipe_confirmedcases, new_data = .) %>%
                select(log_cases, everything())

  pred <-  model %>% predict(new_data = new_data) %>% pull(.pred)

  test_data$log_cases[test_data$date == test_dates$date[i]] <- pred
}
#Calculating the cumlative values
#lastvalue
last_value <- test_data %>%
              filter(date == test_dates$date[1] - days(1)) %>%
              mutate(last_value = confirmed + 1) %>%
              select(country, last_value)

cases_pred_ml <- test_data %>%
              filter(date >= test_dates$date[1]) %>%
              arrange(country, date) %>%
              group_by(country) %>%
              mutate(log_cases = exp(cumsum(log_cases))) %>%
              ungroup() %>%
              inner_join(last_value, by = "country") %>%
              mutate(pred_confirmed = log_cases * (last_value - 1))

return(cases_pred_ml)
}

cases_pred_ml_test <- recursive_pred(xgboost_fit)


cases_pred_ml_test %>%
filter(country == "Germany") %>%
ggplot(aes(x = date)) +
  geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Forecast Accuracy xgboost recursive Germany")

cases_pred_ml_test %>%
  group_by(date) %>%
  summarise(confirmed = sum(confirmed),
            pred_confirmed = sum(pred_confirmed)) %>%
ggplot(aes(x = date)) +
  geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Forecast Accuracy xgboost recursive world-wide")


reg_metrics <- metric_set(rmse, mae, mape)

perf_ml_cases_recursive <-   cases_pred_ml_test %>%
                              group_by(country) %>%
                              reg_metrics(truth = confirmed, estimate = pred_confirmed) %>%
                              mutate(.metric = toupper(.metric),
                                     .model = "recursive_xgb") %>%
                              pivot_wider(names_from = .metric, values_from = .estimate) %>%
                              select(-.estimator)

perf_ml_cases_recursive %>%
                    ggplot(aes(x = MAPE)) +
                    geom_histogram(bins = 50) +
                    ggtitle("Model Accuracy(MAPE) xgboost recursive ")

#check if challenger model has a better performance

 if(train_challenger){

    cases_pred_challenger <- recursive_pred(challenger_fit)

   mae_orig_model <- cases_pred_ml_test %>%
   reg_metrics(truth = confirmed, estimate = pred_confirmed) %>%
   mutate(.metric = toupper(.metric),
   .model = "recursive_xgb") %>%
   pivot_wider(names_from = .metric, values_from = .estimate) %>%
   select(-.estimator) %>%
   pull(MAE)

   mae_challenger_model <- cases_pred_challenger %>%
   reg_metrics(truth = confirmed, estimate = pred_confirmed) %>%
   mutate(.metric = toupper(.metric),
   .model = "recursive_xgb") %>%
   pivot_wider(names_from = .metric, values_from = .estimate) %>%
   select(-.estimator) %>%
   pull(MAE)

   #replace old model if challenger performs better
   if(mae_challenger_model < mae_orig_model){

    #save old model with timestamp
     saveRDS(xgb_tune, paste0("models/", today(),"_model.rds"))
    #save new prod model
     saveRDS(challenger_tune, "models/model.rds")

    xgb_tune <- challenger_tune
    xgboost_fit <- challenger_fit

   }

 }

### fit model on whole dataset and make prediction for the future
##Final Model (Full Dataset)
params_xgboost_best <- xgb_tune %>%
    select_best("mae", maximize = FALSE)

#Finalize the Model for testing
xgboost_finalized <- xgboost_model %>%
    finalize_model(params_xgboost_best)


training_set_full <-  train_lagged  %>%
  bind_rows(test) %>%
  bake(recipe_confirmedcases, new_data = .) %>%
  select(log_cases, everything())

xgboost_fit_final <- xgboost_finalized %>%
                     fit(log_cases ~.,
                     training_set_full)

vip(xgboost_fit_final) +
    labs(title = "XGBoost Model Importance")


# forecast 14 days
test_dates <- data.frame(date = seq(max(test$date) + days(1), by = "days", length.out = 14))

#create prediction dataframe
pred_data <- test %>%
             filter(date == max(date)) %>%
             select(-date) %>%
             crossing(test_dates) %>%
             arrange(date, country)


test_data <- test %>%
  filter( date > max(date) - days(lag)) %>%
  bind_rows(pred_data)
i <- 1

for(i in 1 : nrow(test_dates)){
  new_data <- test_data %>%
              filter(date > test_dates$date[i] - days(period) & date <= test_dates$date[i])
   new_data <- new_data %>%
                group_by(country) %>%
                mutate_at(vars(log_cases), funs_(lag_functions_cases)) %>%
                ungroup() %>%
                filter(date == test_dates$date[i]) %>%
                bake(recipe_confirmedcases, new_data = .) %>%
                select(log_cases, everything())

  pred <-  xgboost_fit_final %>% predict(new_data = new_data) %>% pull(.pred)

  test_data$log_cases[test_data$date == test_dates$date[i]] <- pred
}
#Calculating the cumlative values
#lastvalue
last_value <- test_data %>%
              filter(date == test_dates$date[1] - days(1)) %>%
              mutate(last_value = confirmed + 1) %>%
              select(country, last_value)

cases_pred_ml <- test_data %>%
              filter(date >= test_dates$date[1]) %>%
              arrange(country, date) %>%
              group_by(country) %>%
              mutate(log_cases = exp(cumsum(log_cases))) %>%
              ungroup() %>%
              inner_join(last_value, by = "country") %>%
              mutate(pred_confirmed = log_cases * (last_value - 1),
                     confirmed = NA)

covid %>%
  filter(country %in% unique(train$country)) %>%
bind_rows(cases_pred_ml) %>%
filter(country == "Germany") %>%
ggplot(aes(x = date)) +
   geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Forecast Germany 14 Days ahead") +
  ylab("Predicted Confirmed Cases")

covid %>%
filter(country %in% unique(train$country)) %>%
bind_rows(cases_pred_ml) %>%
  group_by(date) %>%
  summarise(confirmed = sum(confirmed),
            pred_confirmed = sum(pred_confirmed)) %>%
ggplot(aes(x = date)) +
     geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Forecast world-wide 14 Days ahead") +
  ylab("Predicted Confirmed Cases")


```

## Direct Strategy

```{r message=FALSE, warning=FALSE}

#order matters,  the data is ordered by date first than by country
X_train <-  train_lagged  %>%
  filter(date <= max(date) - days(period)) %>%
  select(- all_of(col_rem)) %>%
  bake(recipe_confirmedcases, new_data = .) %>%
  select(log_cases, everything())

y_train <- X_train$log_cases

#the test set consisting
# of the  most recent values of the training set. It's the
# same for all models.
X_test <-  train_lagged  %>%
  filter(date == max(date) - days(period)) %>%
  select(- all_of(col_rem)) %>%
  bake(recipe_confirmedcases, new_data = .) %>%
  select(log_cases, everything())


forecasts_direct <- train_lagged %>%
                    filter(date > max(date) - days(period)) %>%
                    select(date, country, log_cases, confirmed) %>%
                    mutate(pred = as.numeric(NA))

i <- 1
from <- 1
to  <- n_countries
for(i in 1 : period){
  print(i)
    # fit the model
  fit_rf <- xgboost_finalized %>%
  fit_xy(x = X_train[, -1],
         y = y_train)

  # predict using the test set
  forecasts_direct[from : to, "pred"] <- fit_rf %>% predict(new_data = X_test[,-1]) %>% pull(.pred)

  # here is where we repeatedly reshape the training data to reflect the time distance
  # corresponding to the current forecast horizon.
  y_train <- y_train[-(1 : n_countries)]

  X_train <- X_train[-(nrow(X_train) :(nrow(X_train) - n_countries + 1)), ]

  from <- from + n_countries
  to  <- to + n_countries

}

#Calculating the cumlative values
#lastvalue
last_value <- train_lagged  %>%
              filter(date == max(date)) %>%
              mutate(last_value = confirmed + 1) %>%
              select(country, last_value)

cases_pred_ml_direct_test <- forecasts_direct %>%
                        arrange(country, date) %>%
                        group_by(country) %>%
                        mutate(log_cases = exp(cumsum(pred))) %>%
                        ungroup() %>%
                        inner_join(last_value, by = "country") %>%
                        mutate(pred_confirmed = log_cases * (last_value - 1))

performance_direct <- cases_pred_ml_direct_test %>%
                      group_by(country) %>%
                       reg_metrics(truth = confirmed, estimate = pred_confirmed) %>%
                       mutate(.metric = toupper(.metric),
                       .model = "xgb_direct") %>%
                       pivot_wider(names_from = .metric, values_from = .estimate) %>%
                       select(-.estimator)

cases_pred_ml_direct_test %>%
filter(country == "Germany") %>%
ggplot(aes(x = date)) +
  geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Forecast Accuracy xgboost direct Germany")

cases_pred_ml_direct_test %>%
  group_by(date) %>%
  summarise(confirmed = sum(confirmed),
            pred_confirmed = sum(pred_confirmed)) %>%
ggplot(aes(x = date)) +
  geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Forecast Accuracy xgboost direct world-wide")


# fit model on whole dataset and make prediction for the future
X_train <-  train_lagged  %>%
  bind_rows(test) %>%
  select(- all_of(col_rem)) %>%
  bake(recipe_confirmedcases, new_data = .) %>%
  select(log_cases, everything())
y_train <- X_train$log_cases

#the test set consisting
# of the  most recent values of the training set. It's the
# same for all models.
X_test <-  train_lagged  %>%
  bind_rows(test) %>%
  filter(date == max(date) - days(period)) %>%
  select(- all_of(col_rem)) %>%
  bake(recipe_confirmedcases, new_data = .) %>%
  select(log_cases, everything())

# forecast 14 days
test_dates <- data.frame(date = seq(max(test$date) + days(1), by = "days", length.out = 14))


forecasts_direct <- train_lagged %>%
                    distinct(country) %>%
                    crossing(test_dates) %>%
                    arrange(date, country) %>%
                    select(date, country) %>%
                    mutate(pred = as.numeric(NA))

i <- 1
from <- 1
to  <- n_countries
for(i in 1 : period){
  print(i)
    # fit the model
  fit_rf <- xgboost_finalized %>%
  fit_xy(x = X_train[, -1],
         y = y_train)

  # predict using the test set
  forecasts_direct[from : to, "pred"] <- fit_rf %>% predict(new_data = X_test[,-1]) %>% pull(.pred)

  # here is where we repeatedly reshape the training data to reflect the time distance
  # corresponding to the current forecast horizon.
  y_train <- y_train[-(1 : n_countries)]

  X_train <- X_train[-(nrow(X_train) :(nrow(X_train) - n_countries + 1)), ]

  from <- from + n_countries
  to  <- to + n_countries

}

#Calculating the cumlative values
#lastvalue
last_value <- train_lagged  %>%
              bind_rows(test) %>%
              filter(date == test_dates$date[1] - days(1)) %>%
              mutate(last_value = confirmed + 1) %>%
              select(country, last_value)

cases_pred_ml_direct <- forecasts_direct %>%
                        arrange(country, date) %>%
                        group_by(country) %>%
                        mutate(log_cases = exp(cumsum(pred))) %>%
                        ungroup() %>%
                        inner_join(last_value, by = "country") %>%
                        mutate(pred_confirmed = log_cases * (last_value - 1))

  covid %>%
  filter(country %in% unique(train$country)) %>%
bind_rows(cases_pred_ml_direct) %>%
filter(country == "Germany") %>%
ggplot(aes(x = date)) +
   geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Forecast Germany 14 Days ahead") +
  ylab("xgboost direct - Predicted Confirmed Cases")

covid %>%
filter(country %in% unique(train$country)) %>%
bind_rows(cases_pred_ml_direct) %>%
  group_by(date) %>%
  summarise(confirmed = sum(confirmed),
            pred_confirmed = sum(pred_confirmed)) %>%
ggplot(aes(x = date)) +
     geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Forecast world-wide 14 Days ahead") +
  ylab("xgboost direct - Predicted Confirmed Cases")


```

# Time Series Models 

```{r, message=FALSE, warning=FALSE}

#model training and forecast
period <- 14

#ts should have more than 7 values
length_series <- train %>%
                  group_by(country) %>%
                  summarise( length_series = max(days_since_first_case),
                              ttl_distance_measures = sum(distance_measures))


#create tsibble
train_ts <- train %>%
            select(country, date, confirmed, distance_measures) %>%
             as_tsibble(
                index = date,
                key = country
              )

test_ts <- test %>%
            select(country, date, confirmed, distance_measures) %>%
             as_tsibble(
                index = date,
                key = country
              )
if(retrain_ts){
#training ts models
train_model_long <- train_ts %>%
                    inner_join(length_series, by = "country") %>%
                    filter(length_series > 7) %>%
                    model(
                      ETS = ETS(confirmed),
                      ARIMA = ARIMA(confirmed),
                      ETS_LOG = ETS(log(confirmed + 1)),
                      ARIMA_LOG = ARIMA(log(confirmed + 1)),
                     # NNETAR = NNETAR(confirmed),
                      NAIVE = NAIVE(confirmed))


#forecast 14 days
train_forecast_long <- train_model_long %>%
                  forecast(h = paste0(period, " days"))

saveRDS(train_forecast_long, "data/train_forecast_long.rds")


#train regarima model
train_model_regarima <- train_ts %>%
                        inner_join(length_series, by = "country") %>%
                        filter(length_series > 7 & ttl_distance_measures > 0) %>%
                        model(regarima = ARIMA(confirmed ~ distance_measures))

new_data <- train_ts %>%
  filter(date == max(date)) %>%
  inner_join(length_series, by = "country") %>%
  filter(length_series > 7 & ttl_distance_measures > 0) %>%
  as_tibble() %>%
  select(country, distance_measures)


new_data <- train_ts %>%
              filter(date == max(date)) %>%
              new_data(., period) %>%
              inner_join(new_data, by = "country")

train_forecast_regarima <- train_model_regarima %>% forecast(new_data)
saveRDS(train_forecast_regarima, "data/train_forecast_regarima.rds")
} else {
  #read saved mode forecast
  train_forecast_long <- readRDS("data/train_forecast_long.rds")
  train_forecast_regarima<- readRDS("data/train_forecast_regarima.rds")
}

#fitted values
# ts_fitted <- train_model_long %>%
#             fitted() %>%
#             pivot_wider(names_from = .model, values_from = .fitted)

#check model performance on test set
best_model_long <- train_forecast_long %>%
  fabletools::accuracy(test_ts) %>%
  arrange(country, RMSE)

best_model_regarima <- train_forecast_regarima %>%
                       fabletools::accuracy(test_ts)

perf_ts_model <- best_model_long %>%
                 bind_rows(best_model_regarima)


best_model_cases <-  perf_ts_model %>%
                    arrange(country, RMSE) %>%
                    group_by(country) %>%
                    slice(1)

#accuracy germany
train_forecast_long %>%
as_tibble() %>%
bind_rows(train_forecast_regarima %>% as_tibble()) %>%
filter(.model ==  best_model_cases %>% filter(country == "Germany") %>% pull(.model)) %>%
bind_rows(test_ts %>% mutate(.model = "truth")) %>%
  filter(country =="Germany") %>%
 ggplot(aes(x = date, y = confirmed, color = .model)) +
 geom_line(size = 1) +
  scale_color_tableau() +
  ggtitle("Forecast Accuracy TS Model Germany")

#accuracy world - wide
train_forecast_long %>%
as_tibble() %>%
bind_rows(train_forecast_regarima %>% as_tibble()) %>%
inner_join(best_model_cases, by = c("country", ".model")) %>%
mutate(.model = "pred") %>%
bind_rows(test_ts %>% mutate(.model = "truth")) %>%
group_by(date, .model) %>%
summarise(confirmed = sum(confirmed)) %>%
ggplot(aes(x = date , y = confirmed, color = .model))+
geom_line(size = 1) +
scale_color_tableau() +
ggtitle("Forecast Accuracy TS Model world-wide")

best_model_cases <-  perf_ts_model %>%
                    arrange(country, RMSE) %>%
                    group_by(country) %>%
                    slice(1)

p1 <- best_model_cases %>% ggplot(aes(x = .model)) +
      geom_bar() +
      ggtitle("Selected TS Models") +
      xlab("Best Model")

p2 <- best_model_cases %>%
      ggplot(aes(x = MAPE)) +
      geom_histogram(bins = 30) +
      ggtitle("Accuracy of selected Models(MAPE)")

grid.arrange(p1, p2, nrow = 1)

#fit all models on whole dataset and forecast 14 days ahead
if(retrain_ts){
period <-  14

full_data <- train %>%
                        bind_rows(test) %>%
                        select(country, date, confirmed, distance_measures) %>%
                        as_tsibble(
                        index = date,
                        key = country
                        )

pred_best_model_ts <- function(x, target = "confirmed"){
model_country <- best_model_cases %>% filter(.model == x) %>% pull(country)
#log models
  if(str_detect("ETS_LOG","LOG")){
    x <- str_replace(x,"_LOG","")
      model <- full_data %>%
        filter(country %in% model_country ) %>%
        model(x = eval(parse(text = x))(log(!! sym(target) + 1))) %>%
        forecast(h = paste0(period, " days")) %>%
        as.data.frame() %>%
        mutate(.model = x) %>%
        select(1 : 4)
  } else {
        model <- full_data %>%
        filter(country %in% model_country ) %>%
        model(x = eval(parse(text = x))(!! sym(target))) %>%
        forecast(h = paste0(period, " days")) %>%
        as.data.frame() %>%
        mutate(.model = x) %>%
        select(1 : 4)

  }
return(model)
}




#pred regarima best_model
regarima_coutries <- best_model_cases %>%
                      filter(.model =="regarima") %>%
                      pull(country)

train_model_regarima <- full_data %>%
                        filter(country %in% regarima_coutries) %>%
                        model(regarima = ARIMA(confirmed ~ distance_measures))


new_data <- full_data %>%
  filter(date == max(date) & country %in% regarima_coutries) %>%
  as_tibble() %>%
  select(country, distance_measures)


new_data <- full_data %>%
              filter(date == max(date)) %>%
              new_data(., period) %>%
              inner_join(new_data, by = "country")

regarima_pred <- train_model_regarima %>%
                           forecast(new_data) %>%
                           as_tibble() %>%
                           select(1 : 4)
#remaing models

  final_pred <- map_df(
    unique(best_model_cases$.model)[unique(best_model_cases$.model) != "regarima"], pred_best_model_ts, "confirmed")

final_pred <-  final_pred %>%
                bind_rows(regarima_pred) %>%
                rename(pred_confirmed = confirmed)
    write.csv(final_pred, "data/prediction_ts_confirmedcases.csv", row.names = FALSE)
} else {
 final_pred <- read_csv("data/prediction_ts_confirmedcases.csv")
}


  covid %>%
  filter(country %in% unique(final_pred$country)) %>%
bind_rows(final_pred) %>%
filter(country == "Germany") %>%
ggplot(aes(x = date)) +
   geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Time Series Forecast - Germany 14 Days ahead") +
  ylab("Predicted Confirmed Cases")

covid %>%
filter(country %in% unique(final_pred$country)) %>%
bind_rows(final_pred) %>%
  group_by(date) %>%
  summarise(confirmed = sum(confirmed),
            pred_confirmed = sum(pred_confirmed)) %>%
ggplot(aes(x = date)) +
     geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Time Series Forecast - world-wide 14 Days ahead") +
  ylab("Predicted Confirmed Cases")
  

```
# Ensembles
```{r, message=FALSE, warning=FALSE}
#Simple Model Averaging, one could try more complex methods to combine the different models
model_average <- train_forecast_long %>%
                  as.tibble() %>%
                  select(country, date, pred_confirmed = confirmed) %>%
                  bind_rows(
                train_forecast_regarima %>%
                  as.tibble() %>%
                  select(country, date, pred_confirmed = confirmed),
                cases_pred_ml_direct_test %>%
                    select(country, date, pred_confirmed),
                cases_pred_ml_test %>%
                    select(country, date, pred_confirmed)) %>%
                group_by(date, country) %>%
                summarise(pred_confirmed = mean(pred_confirmed)) %>%
                ungroup()

model_average_perf <- model_average %>%
                      inner_join( test , by = c("date", "country")) %>%
                      group_by(country) %>%
                      reg_metrics(truth = confirmed, estimate = pred_confirmed) %>%
                      mutate(.metric = toupper(.metric),
                      .model = "model_average") %>%
                      pivot_wider(names_from = .metric, values_from = .estimate) %>%
                     select(-.estimator)


```

# Model Comparison

```{r, message=FALSE, warning=FALSE}
model_performance <- perf_ts_model %>%
                    bind_rows(perf_ml_cases_recursive) %>%
                    bind_rows(performance_direct) %>%
                    bind_rows(model_average_perf)

model_performance %>%
  ggplot(aes(y = RMSE, x =fct_reorder(.model, RMSE, .desc=TRUE))) +
  geom_boxplot() +
  scale_y_log10()  +
  ggtitle("Performance by Model") +
  xlab("")


best_model_cases <- model_performance %>%
                    arrange(country, RMSE) %>%
                    group_by(country) %>%
                    slice(1)
best_model_cases %>%
  mutate(.model = "best_model") %>%
  bind_rows(model_performance) %>%
  ggplot(aes(y = RMSE, x = fct_reorder(.model, RMSE, .desc=TRUE))) +
  geom_boxplot() +
  scale_y_log10()  +
  ggtitle("Improvement of Using different Models") +
  xlab("")

best_model_cases %>%
  ggplot(aes(x = .model)) +
  geom_bar() +
  ggtitle("Distribution of Selected Model")

```

# Choose Best Prediction and Plot

```{r, message=FALSE, warning=FALSE}

pred_all <- bind_rows(
cases_pred_ml_direct %>%
  mutate(.model ="xgb_direct") %>%
  select(date, country, pred_confirmed, .model),
cases_pred_ml %>%
  mutate(.model = "recursive_xgb") %>%
  select(date, country, pred_confirmed, .model),
final_pred %>%
  select(date, country, pred_confirmed, .model))

pred_all <- pred_all %>%
            bind_rows(
            #average of all predictions
            pred_all %>%
              group_by(date, country) %>%
              summarise(pred_confirmed = mean(pred_confirmed)) %>%
              ungroup() %>%
              mutate(.model = "model_average" )
            ) %>%
              inner_join(best_model_cases, by = c("country", ".model"))


covid %>%
filter(country %in% unique(train$country)) %>%
bind_rows(pred_all) %>%
  group_by(date) %>%
  summarise(confirmed = sum(confirmed),
            pred_confirmed = sum(pred_confirmed)) %>%
ggplot(aes(x = date)) +
     geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle("Final Forecast world-wide 14 Days ahead") +
  ylab("Predicted Confirmed Cases")

#read modelhistory
model_history <- read_csv("data/model_history.csv")

max_id <- max(model_history$model_run_id) + 1

# save model history to check performance
final_pred <- final_pred %>%
  mutate(model_run_id = max_id,
         model_timstamp = today(),
         forecast_from = min(date),
         forecast_to = max(date))

model_history <- model_history %>%
                 bind_rows(final_pred)

write_csv(model_history, "data/model_history.csv")

```

# Historic Model Performance

```{r, message=FALSE, warning=FALSE}

model_performance_hist <- model_history %>%
                      filter(model_run_id == 1) %>%
                      inner_join(covid, by = c("date", "country"))
#Germany
model_performance_hist %>%
  filter(country == "Germany") %>%
  ggplot(aes(x = date)) +
  geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle(paste0("Forecast from ", min(model_performance_hist$date) - days(1), " Germany")) +
  ylab("Predicted Confirmed Cases")

#World Wide
model_performance_hist %>%
  group_by(date) %>%
  summarise(confirmed = sum(confirmed),
            pred_confirmed = sum(pred_confirmed)) %>%
  ggplot(aes(x = date)) +
  geom_line(aes(y = confirmed, color = "truth"), size = 1) +
  geom_line(aes(y = pred_confirmed, color = "forecast"), size = 1) +
  scale_color_manual(values = c(
    'truth' = 'darkorange',
    'forecast' = 'darkblue')) +
  labs(color = '') +
  ggtitle(paste0("Forecast from ", min(model_performance_hist$date) - days(1), " world-wide")) +
  ylab("Predicted Confirmed Cases")

#Overall Performance
model_performance_hist %>%
  group_by(country) %>%
  reg_metrics(truth = confirmed, estimate = pred_confirmed) %>%
  mutate(.metric = toupper(.metric)) %>%
  pivot_wider(names_from = .metric, values_from = .estimate) %>%
  select(-.estimator) %>%
  ggplot(aes(MAPE)) +
  geom_histogram()

model_performance_hist %>%
  reg_metrics(truth = confirmed, estimate = pred_confirmed)


```

